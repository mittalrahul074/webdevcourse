<!doctype html>
<html lang="en">
  <head>
    <title>Title</title>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  </head>
  <body>
      <ul>Introduction</ul>
<p>  Servlets (1997) offer several advantages in comparison with CGI.
 First, performance is significantly better. Servlets execute within the address
space of a Web server. It is not necessary to create a separate process to handle
each client request.
 Servlets are platform-independent because they are written in Java. A number
of Web servers from different vendors offer the Servlet API. Programs
developed for this API can be moved to any of these environments without
recompilation.
 The Java security manager on the server enforces a set of restrictions to
protect the resources on a server machine.
 It can communicate with applets, databases, or other software via the sockets 
and RMI mechanisms. 
What are the Advantage of Servlets Over "Traditional" CGI?
 Java servlets are more efficient, easier to use, more powerful, more
portable,and cheaper than traditional CGI.
 Efficient. With traditional CGI, a new process is started for each HTTP
request. If the CGI program does a relatively fast operation, the overhead of
starting the process can dominate the execution time. With servlets, the Java
Virtual Machine stays up, and each request is handled by a lightweight Java
thread, not a heavyweight operating system process. Similarly, in traditional
CGI, if there are N simultaneous request to the same CGI program, then the
code for the CGI program is loaded into memory N times. With servlets,
however, there are N threads but only a single copy of the servlet class.
Servlets also have more alternatives than do regular CGI programs for
optimizations such as caching previous computations, keeping database
connections open,and the like.
 Convenient. Hey, you already know Java. Why learn Perl too? Besides the
convenience of being able to use a familiar language, servlets have an
extensive infrastructure for automatically parsing and decoding HTML
form data, reading and setting HTTP headers, handling cookies, tracking
sessions, and many other such utilities.
 Powerful. Java servlets let you easily do several things that are difficult or
impossible with regular CGI. For one thing, servlets can talk directly to the
Web server (regular CGI programs can't). This simplifies operations that
need to look up images and other data stored in standard places. Servlets
can also share data among each other, making useful things like database
connection pools easy to implement. They can also maintain information
from request to request, simplifying things like session tracking and caching
of previous computations.
 Portable. Servlets are written in Java and follow a well-standardized API.
Consequently, servlets written for, say I-Planet Enterprise Server can run
virtually unchanged on Apache, Microsoft IIS, or WebStar. Servlets are
supported directly or via a plugin on almost every majorWeb server.
 Inexpensive. There are a number of free or very inexpensive Web servers
available that are good for "personal" use or low-volume Web sites.
However, with the major exception of Apache, which is free, most
commercial-quality Web servers are relatively expensive. Nevertheless,
once you have a Web server, no matter the cost of that server, adding
servlet support to it (if it doesn't come preconfigured to support servlets)
is generally free or cheap.</p>  
      <ul>Servlet Life Cycle</ul>
    <p> Methods: init( ), service( ), and destroy( ).
 They are implemented by every servlet and are invoked at specific
times by the server.
 First, assume that a user enters a Uniform Resource Locator (URL) to
a Web browser. The browser then generates an HTTP request for this
URL.This request is then sent to the appropriate server.
 Second, this HTTP request is received by the Web server. The server
maps this request to a particular servlet. The servlet is dynamically
retrieved and loaded into the address space of the server.

 Third, the server invokes the init( ) method of the servlet. This method
is invoked only when the servlet is first loaded into memory. It is possible to
pass initialization parameters to the servlet so it may configure itself.
public void init(ServletConfig config) throws ServletException
 Fourth, the server invokes the service( ) method of the servlet. This
method is called to process the HTTP request. It is possible for the
servlet to read data that has been provided in the HTTP request. It may
also formulate an HTTP response for the client.
public void service(ServletRequest request, ServletResponse response) 
throws ServletException, IOException

 The servlet remains in the server’s address space and is available to process any
other HTTP requests received from clients. The service( ) method is called
for each HTTP request.
 Finally, the server may decide to unload the servlet from its memory.
The algorithms by which this determination is made are specific to each
server. The server calls the destroy( ) method to relinquish any
resources such as file handles that are allocated for the servlet. Important
data may be saved to a persistent store. The memory allocated for the servlet
and its objects can then be garbage collected.
public void destroy()
Architecture-
The following figure depicts a typical servlet life-cycle scenario.
1)First the HTTP requests coming to the server are delegated to the servlet container.
2)The servlet container loads the servlet before invoking the service() method.
3)Then the servlet container handles multiple requests by spawning multiple threads, each thread executing the service() method of a single instance of the servlet.<p/>

      <ul>Handling HTTP request</ul>
    <p>When a browser requests for a web page, it sends lot of information to the web server which cannot be read directly because this information travel as a part of header of HTTP request. You can check HTTP Protocol for more information on this.

Following is the important header information which comes from browser side and you would use very frequently in web programming −

Sr.No.	Header & Description
1	
Accept
This header specifies the MIME types that the browser or other clients can handle. Values of image/png or image/jpeg are the two most common possibilities.

2	
Accept-Charset
This header specifies the character sets the browser can use to display the information. For example ISO-8859-1.

3	
Accept-Encoding
This header specifies the types of encodings that the browser knows how to handle. Values of gzip or compress are the two most common possibilities.

4	
Accept-Language
This header specifies the client's preferred languages in case the servlet can produce results in more than one language. For example en, en-us, ru, etc

5	
Authorization
This header is used by clients to identify themselves when accessing password-protected Web pages.

6	
Connection
This header indicates whether the client can handle persistent HTTP connections. Persistent connections permit the client or other browser to retrieve multiple files with a single request. A value of Keep-Alive means that persistent connections should be used.

7	
Content-Length
This header is applicable only to POST requests and gives the size of the POST data in bytes.

8	
Cookie
This header returns cookies to servers that previously sent them to the browser.

9	
Host
This header specifies the host and port as given in the original URL.

10	
If-Modified-Since
This header indicates that the client wants the page only if it has been changed after the specified date. The server sends a code, 304 which means Not Modified header if no newer result is available.

11	
If-Unmodified-Since
This header is the reverse of If-Modified-Since; it specifies that the operation should succeed only if the document is older than the specified date.

12	
Referer
This header indicates the URL of the referring Web page. For example, if you are at Web page 1 and click on a link to Web page 2, the URL of Web page 1 is included in the Referrer header when the browser requests Web page 2.

13	
User-Agent
This header identifies the browser or other client making the request and can be used to return different content to different types of browsers.

Methods to read HTTP Header
There are following methods which can be used to read HTTP header in your servlet program. These methods are available with HttpServletRequest object

Sr.No.	Method & Description
1	
Cookie[] getCookies()
Returns an array containing all of the Cookie objects the client sent with this request.

2	
Enumeration getAttributeNames()
Returns an Enumeration containing the names of the attributes available to this request.

3	
Enumeration getHeaderNames()
Returns an enumeration of all the header names this request contains.

4	
Enumeration getParameterNames()
Returns an Enumeration of String objects containing the names of the parameters contained in this request

5	
HttpSession getSession()
Returns the current session associated with this request, or if the request does not have a session, creates one.

6	
HttpSession getSession(boolean create)
Returns the current HttpSession associated with this request or, if if there is no current session and value of create is true, returns a new session.

7	
Locale getLocale()
Returns the preferred Locale that the client will accept content in, based on the Accept-Language header.

8	
Object getAttribute(String name)
Returns the value of the named attribute as an Object, or null if no attribute of the given name exists.

9	
ServletInputStream getInputStream()
Retrieves the body of the request as binary data using a ServletInputStream.

10	
String getAuthType()
Returns the name of the authentication scheme used to protect the servlet, for example, "BASIC" or "SSL," or null if the JSP was not protected.

11	
String getCharacterEncoding()
Returns the name of the character encoding used in the body of this request.

12	
String getContentType()
Returns the MIME type of the body of the request, or null if the type is not known.

13	
String getContextPath()
Returns the portion of the request URI that indicates the context of the request.

14	
String getHeader(String name)
Returns the value of the specified request header as a String.

15	
String getMethod()
Returns the name of the HTTP method with which this request was made, for example, GET, POST, or PUT.

16	
String getParameter(String name)
Returns the value of a request parameter as a String, or null if the parameter does not exist.

17	
String getPathInfo()
Returns any extra path information associated with the URL the client sent when it made this request

18	
String getProtocol()
Returns the name and version of the protocol the request.

19	
String getQueryString()
Returns the query string that is contained in the request URL after the path.

20	
String getRemoteAddr()
Returns the Internet Protocol (IP) address of the client that sent the request.

21	
String getRemoteHost()
Returns the fully qualified name of the client that sent the request.

22	
String getRemoteUser()
Returns the login of the user making this request, if the user has been authenticated, or null if the user has not been authenticated.

23	
String getRequestURI()
Returns the part of this request's URL from the protocol name up to the query string in the first line of the HTTP request.

24	
String getRequestedSessionId()
Returns the session ID specified by the client.

25	
String getServletPath()
Returns the part of this request's URL that calls the JSP.

26	
String[] getParameterValues(String name)
Returns an array of String objects containing all of the values the given request parameter has, or null if the parameter does not exist.

27	
boolean isSecure()
Returns a Boolean indicating whether this request was made using a secure channel, such as HTTPS.

28	
int getContentLength()
Returns the length, in bytes, of the request body and made available by the input stream, or -1 if the length is not known.

29	
int getIntHeader(String name)
Returns the value of the specified request header as an int.

30	
int getServerPort()
Returns the port number on which this request was received.

HTTP Header Request Example
Following is the example which uses getHeaderNames() method of HttpServletRequest to read the HTTP header information. 
This method returns an Enumeration that contains the header information associated with the current HTTP request.
Once we have an Enumeration, we can loop down the Enumeration in the standard manner, using hasMoreElements() method to determine 
when to stop and using nextElement() method to get each parameter name

// Import required java libraries
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.util.*;
 
// Extend HttpServlet class
public class DisplayHeader extends HttpServlet {
// Method to handle GET method request.
public void doGet(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
// Set response content type
response.setContentType("text/html");
PrintWriter out = response.getWriter();
String title = "HTTP Header Request Example";
String docType =
"<!doctype html public \"-//w3c//dtd html 4.0 " + "transitional//en\">\n";
 out.println(docType +
"<html>\n" +
"<head><title>" + title + "</title></head>\n"+
"<body bgcolor = \"#f0f0f0\">\n" +
"<h1 align = \"center\">" + title + "</h1>\n" +
"<table width = \"100%\" border = \"1\" align = \"center\">\n" +
"<tr bgcolor = \"#949494\">\n" +
"<th>Header Name</th><th>Header Value(s)</th>\n"+
"</tr>\n"
  );
 
Enumeration headerNames = request.getHeaderNames();
while(headerNames.hasMoreElements()) {
String paramName = (String)headerNames.nextElement();
out.print("<tr><td>" + paramName + "</td>\n");
String paramValue = request.getHeader(paramName);
out.println("<td> " + paramValue + "</td></tr>\n");
 }
out.println("</table>\n</body></html>");
 }
// Method to handle POST method request.
public void doPost(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
doGet(request, response);
   }
}
Now calling the above servlet would generate the following result −
HTTP Header Request Example
Header Name	Header Value(s)
accept	*/*
accept-language	en-us
user-agent	Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; InfoPath.2; MS-RTC LM 8)
accept-encoding	gzip, deflate
host	localhost:8080
connection	Keep-Alive
cache-control	no-cache</p>
      <ul>Get and Post request</ul>
<p> doGet is called in response to an HTTP GET request.
void doGet(HttpServletRequest req, HttpServletResponse res)
throws IOException, ServletException
 doPost is called in response to an HTTP POST request.
void doPost(HttpServletRequest req,HttpServletResponse res)
throws IOException, ServletException

<form action="form_action.asp" method="get">
First name: <input type="text" name="fname" /><br />
Last name: <input type="text" name="lname" /><br />
<input type="submit" value="Submit" />
</form> 
HTML 
Code
 Generally, doGet() or doPost() methods are needed to be overridden to
handle the GET or POST requests.
 With the GET method, the data is appended to the URL with a special
syntax. You've probably seen URLs such as
http://bloggs.com/forum?id=774. Here, the id parameter is given the
value 774 directly in the URL.
 This method is suitable for short data and/or cases where it is desirable
for the parameters to be 'visible' in the URL (for example, some search
engines pick them up).
 In the POST method, the URL visible to the user is just
http://bloggs.com/forum, and any parameter setting is "hidden" in
the communication with the server.

protected void doGet(HttpServletRequest request, HttpServletResponse 
response) throws ServletException, IOException {
response.setContentType("text/html”);
PrintWriter out = response.getWriter();
Date d=new Date();
out.println("<html>"); out.println("<head>");
out.println("<title>Servlet secondservlet</title>"); 
out.println("</head>"); out.println("<body>");
out.println("<h1>" + d + "</h1>");
out.println("</body>"); out.println("</html>");
out.close(); } }</p>
      <ul>Redirecting Request</ul>
<p>Page redirection is a technique where the client is sent to a new location other than requested. Page redirection is generally used 
  when a document moves to a new location or may be because of load balancing.

The simplest way of redirecting a request to another page is using method sendRedirect() of response object. Following is the signature of this method −

public void HttpServletResponse.sendRedirect(String location) 
throws IOException 
This method sends back the response to the browser along with the status code and new page location. You can also use setStatus() 
and setHeader() methods together to achieve the same −

.... 
String site = "http://www.newpage.com" ; 
response.setStatus(response.SC_MOVED_TEMPORARILY); 
response.setHeader("Location", site);  
.... 
  Example:protected void processRequest(HttpServletRequest request, 
HttpServletResponse response) throws ServletException, IOException {
response.setContentType("text/html "); 
PrintWriter out = response.getWriter();
try { out.println("<html><body>");
String name=request.getParameter("uname"); 
String password=request.getParameter("pwd");
if(name.equals("marees") && password.equals("msw"))
response.sendRedirect("http://www.vit.ac.in");
else out.println("<b>Invalid User</b>");
out.println("</body></html>"); } finally {out.close(); } } 
In NetBeans
 File  New project Java Web Web Application
 Project Name: First Project Location: C:\Temp  Next
 Server : Apache Tomcat 6.0.18  Next Finish
 File  New File Web  Servlet Next
 Class Name : Welcome  Next  Finish
 Do changes in try block
 Run  Build Project (First)
 See the message “Build Successful “ in bottom of the running window
 Run  Run File or Source PackagesWelcome.java  (right click ) 
 Run File</p>
      <ul>JSP Overview</ul>
<p>What is JavaServer Pages?
JavaServer Pages (JSP) is a technology for developing Webpages that supports dynamic content. This helps developers insert java code 
in HTML pages by making use of special JSP tags, most of which start with <% and end with %>.

A JavaServer Pages component is a type of Java servlet that is designed to fulfill the role of a user interface for a Java web application. 
  Web developers write JSPs as text files that combine HTML or XHTML code, XML elements, and embedded JSP actions and commands.

Using JSP, you can collect input from users through Webpage forms, present records from a database or another source, and create Webpages dynamically.

JSP tags can be used for a variety of purposes, such as retrieving information from a database or registering user preferences, 
accessing JavaBeans components, passing control between pages, and sharing information between requests, pages etc.

Why Use JSP?
JavaServer Pages often serve the same purpose as programs implemented using the Common Gateway Interface (CGI). 
But JSP offers several advantages in comparison with the CGI.

Performance is significantly better because JSP allows embedding Dynamic Elements in HTML Pages itself instead of having separate CGI files.

JSP are always compiled before they are processed by the server unlike CGI/Perl which requires the server to load an interpreter 
and the target script each time the page is requested.

JavaServer Pages are built on top of the Java Servlets API, so like Servlets, JSP also has access to all the powerful Enterprise 
Java APIs, including JDBC, JNDI, EJB, JAXP, etc.

JSP pages can be used in combination with servlets that handle the business logic, the model supported by Java servlet template engines.

Finally, JSP is an integral part of Java EE, a complete platform for enterprise class applications. This means that JSP can play a part in the 
simplest applications to the most complex and demanding.

Advantages of JSP
Following table lists out the other advantages of using JSP over other technologies −

 Active Server Pages (ASP)
The advantages of JSP are twofold. First, the dynamic part is written in Java, not Visual Basic or other MS specific language, 
so it is more powerful and easier to use. Second, it is portable to other operating systems and non-Microsoft Web servers.

Pure Servlets
It is more convenient to write (and to modify!) regular HTML than to have plenty of println statements that generate the HTML.

Server-Side Includes (SSI)
SSI is really only intended for simple inclusions, not for "real" programs that use form data, make database connections, and the like.

JavaScript
JavaScript can generate HTML dynamically on the client but can hardly interact with the web server to perform complex tasks like database access and image processing etc.

Static HTML
Regular HTML, of course, cannot contain dynamic information.</p>
      <ul>Objects</ul>
<p>In this chapter, we will discuss the Implicit Objects in JSP. These Objects are the Java objects that the JSP Container makes available to the 
  developers in each page and the developer can call them directly without being explicitly declared. JSP Implicit Objects are also called pre-defined variables.

Following table lists out the nine Implicit Objects that JSP supports −

S.No.	Object & Description
1	
request
This is the HttpServletRequest object associated with the request.

2	
response
This is the HttpServletResponse object associated with the response to the client.

3	
out
This is the PrintWriter object used to send output to the client.

4	
session
This is the HttpSession object associated with the request.

5	
application
This is the ServletContext object associated with the application context.

6	
config
This is the ServletConfig object associated with the page.

7	
pageContext
This encapsulates use of server-specific features like higher performance JspWriters.

8	
page
This is simply a synonym for this, and is used to call the methods defined by the translated servlet class.

9	
Exception
The Exception object allows the exception data to be accessed by designated JSP.

The request Object
The request object is an instance of a javax.servlet.http.HttpServletRequest object. Each time a client requests a page the JSP engine creates 
a new object to represent that request.

The request object provides methods to get the HTTP header information including form data, cookies, HTTP methods etc.

We can cover a complete set of methods associated with the request object in a subsequent chapter − JSP - Client Request.

The response Object
The response object is an instance of a javax.servlet.http.HttpServletResponse object. Just as the server creates the request object, 
it also creates an object to represent the response to the client.

The response object also defines the interfaces that deal with creating new HTTP headers. Through this object the JSP programmer can 
add new cookies or date stamps, HTTP status codes, etc.

We will cover a complete set of methods associated with the response object in a subsequent chapter − JSP - Server Response.

The out Object
The out implicit object is an instance of a javax.servlet.jsp.JspWriter object and is used to send content in a response.

The initial JspWriter object is instantiated differently depending on whether the page is buffered or not. Buffering can be easily turned 
off by using the buffered = 'false' attribute of the page directive.

The JspWriter object contains most of the same methods as the java.io.PrintWriter class. However, JspWriter has some additional methods designed 
to deal with buffering. Unlike the PrintWriter object, JspWriter throws IOExceptions.

Following table lists out the important methods that we will use to write boolean char, int, double, object, String, etc.

S.No.	Method & Description
1	
out.print(dataType dt)
Print a data type value

2	
out.println(dataType dt)
Print a data type value then terminate the line with new line character.

3	
out.flush()
Flush the stream.

The session Object
The session object is an instance of javax.servlet.http.HttpSession and behaves exactly the same way that session objects behave under Java Servlets.
The session object is used to track client session between client requests. We will cover the complete usage of session object in a subsequent chapter − JSP - Session Tracking.

The application Object
The application object is direct wrapper around the ServletContext object for the generated Servlet and in reality an instance of a javax.servlet.ServletContext object.
This object is a representation of the JSP page through its entire lifecycle. This object is created when the JSP page is initialized and will be 
removed when the JSP page is removed by the jspDestroy() method.

By adding an attribute to application, you can ensure that all JSP files that make up your web application have access to it.
We will check the use of Application Object in JSP - Hits Counter chapter.

The config Object
The config object is an instantiation of javax.servlet.ServletConfig and is a direct wrapper around the ServletConfig object for the generated servlet.

This object allows the JSP programmer access to the Servlet or JSP engine initialization parameters such as the paths or file locations etc.
The following config method is the only one you might ever use, and its usage is trivial −

config.getServletName();
This returns the servlet name, which is the string contained in the <servlet-name> element defined in the WEB-INF\web.xml file.

The pageContext Object
The pageContext object is an instance of a javax.servlet.jsp.PageContext object. The pageContext object is used to represent the entire JSP page.

This object is intended as a means to access information about the page while avoiding most of the implementation details.

This object stores references to the request and response objects for each request. The application, config, session, and out objects 
are derived by accessing attributes of this object.

The pageContext object also contains information about the directives issued to the JSP page, including the buffering information, the errorPageURL, and page scope.

The PageContext class defines several fields, including PAGE_SCOPE, REQUEST_SCOPE, SESSION_SCOPE, and APPLICATION_SCOPE, which 
identify the four scopes. It also supports more than 40 methods, about half of which are inherited from the javax.servlet.jsp.JspContext class.

One of the important methods is removeAttribute. This method accepts either one or two arguments. For example, pageContext.removeAttribute ("attrName") 
removes the attribute from all scopes, while the following code only removes it from the page scope −

pageContext.removeAttribute("attrName", PAGE_SCOPE);
The use of pageContext can be checked in JSP - File Uploading chapter.

The page Object
This object is an actual reference to the instance of the page. It can be thought of as an object that represents the entire JSP page.

The page object is really a direct synonym for the this object.

The exception Object
The exception object is a wrapper containing the exception thrown from the previous page. It is typically used to generate an appropriate response to the error condition.</p>
      <ul>Standardactions</ul>
<p>JSP actions are special XML tags that control the behavior of the servlet engine. JSP actions allow you to insert a file dynamically, 
 reuse external JavaBean components, forward the request to the other page and generate HTML for Java Applet Plugin.

jsp:include action
JSP include action allows you to include a file at runtime. The syntax of JSP include action is as follows:

<jsp:include page="Relative URL" flush="true" />
Code language: HTML, XML (xml)
In the page attribute, you insert a relative URL of a file which could be an HTML file or another JSP page. Unlike the include directive, 
the jsp include action insert a file at the time page is being requested.

jsp:useBean action
JSP useBean action lets you load a JavaBean component into the page and use it later. JSP useBean action allows you to reuse other Java classes. 
The syntax of JSP useBean action is as follows:

<jsp:useBean id="objectName" class="package.class" />
Code language: JavaScript (javascript)
By using the jsp:useBean action, you create a new object with the object nameobjectName of the class package.class. Later on, you can access the
properties of this object by using either jsp:setProperty or jsp:getProperty. Let’s take a look at an example. First, we have a JavaBeans call Message:

public class Message {

    private String text;

    /**
     * @return the text
     */
    public String getText() {
        return text;
    }

    /**
     * @param text the text to set
     */
    public void setText(String text) {
        this.text = text;
    }
}
Code language: PHP (php)
Then we create a JSP page that uses the jsp:useBean action to access JavaBean Message inside that page.

<html>
    <head>
        <title>jsp:useBean Demo</title>
    </head>
    <body>
        <jsp:useBean id="msg"
                     class="com.jsptutorial.Message" />

        <jsp:setProperty name="msg" 
                         property="text"
                         value="JSP useBean Demo" />
        <h1>
        <jsp:getProperty name="msg"
                         property="text" />
        </h1>

    </body>
</html>
Code language: HTML, XML (xml)
We use jsp:setProperty to set the text property of the JavaBean Message and then we call jsp:getProperty to get that message and print it out. Here is the output screenshot:


jsp:forward Action
jsp:forward action allows you to forward a request to the other page. The syntax of the jsp:forward action is listed as below.
There is one attribute called page which value is a page you want to forward the request to. You can specify the page statically or dynamically by using the expression.

<jsp:forward page="error.jsp" />
<jsp:forward page="<%= java-expression %>" />
Code language: HTML, XML (xml)
jsp:plugin Action
jsp:plugin action allows you to embedded Java Applet into a page. Suppose you have an applet which demonstrates the JSP page life cycle 
called com.jsp.jspapplet. Here is the way we use jsp:plugin action to embedded that applet into a page:

<html>
<head>
<title>jsp:plugin Demo</title>
</head>
<body>
<jsp:plugin type="applet" 
            code="com.jsp.jspapplet" 
            codebase="."    
            width="500" 
            height="400">
    <jsp:fallback>
        <p>Unable to use Java Plugin</p>
    </jsp:fallback>
</jsp:plugin>

</body>
</html></p>
      <ul>Directives</ul>
<p>Directives provide directions and instructions to the container, telling it how to handle certain aspects of the JSP processing.

A JSP directive affects the overall structure of the servlet class. It usually has the following form −

<%@ directive attribute = "value" %>
Directives can have a number of attributes which you can list down as key-value pairs and separated by commas.

The blanks between the @ symbol and the directive name, and between the last attribute and the closing %>, are optional.

There are three types of directive tag −

S.No.	Directive & Description
1	
<%@ page ... %>
Defines page-dependent attributes, such as scripting language, error page, and buffering requirements.

2	
<%@ include ... %>
Includes a file during the translation phase.

3	
<%@ taglib ... %>
Declares a tag library, containing custom actions, used in the page
JSP - The page Directive
The page directive is used to provide instructions to the container. These instructions pertain to the current JSP page. 
You may code page directives anywhere in your JSP page. By convention, page directives are coded at the top of the JSP page.

Following is the basic syntax of the page directive −

<%@ page attribute = "value" %>
You can write the XML equivalent of the above syntax as follows −

<jsp:directive.page attribute = "value" />
Attributes
Following table lists out the attributes associated with the page directive −

S.No.	Attribute & Purpose
1	
buffer
Specifies a buffering model for the output stream.

2	
autoFlush
Controls the behavior of the servlet output buffer.

3	
contentType
Defines the character encoding scheme.

4	
errorPage
Defines the URL of another JSP that reports on Java unchecked runtime exceptions.

5	
isErrorPage
Indicates if this JSP page is a URL specified by another JSP page's errorPage attribute.

6	
extends
Specifies a superclass that the generated servlet must extend.

7	
import
Specifies a list of packages or classes for use in the JSP as the Java import statement does for Java classes.

8	
info
Defines a string that can be accessed with the servlet's getServletInfo() method.

9	
isThreadSafe
Defines the threading model for the generated servlet.

10	
language
Defines the programming language used in the JSP page.

11	
session
Specifies whether or not the JSP page participates in HTTP sessions

12	
isELIgnored
Specifies whether or not the EL expression within the JSP page will be ignored.

13	
isScriptingEnabled
Determines if the scripting elements are allowed for use.

Check for more details related to all the above attributes at Page Directive.

The include Directive
The include directive is used to include a file during the translation phase. This directive tells the container to merge the 
content of other external files with the current JSP during the translation phase. You may code the include directives anywhere in your JSP page.

The general usage form of this directive is as follows −

<%@ include file = "relative url" >
The filename in the include directive is actually a relative URL. If you just specify a filename with no associated path, the JSP 
compiler assumes that the file is in the same directory as your JSP.

You can write the XML equivalent of the above syntax as follows −

<jsp:directive.include file = "relative url" />
For more details related to include directive, check the Include Directive.

The taglib Directive
The JavaServer Pages API allow you to define custom JSP tags that look like HTML or XML tags and a tag library is a set of user-defined tags that implement custom behavior.

The taglib directive declares that your JSP page uses a set of custom tags, identifies the location of the library, 
and provides means for identifying the custom tags in your JSP page.

The taglib directive follows the syntax given below −

<%@ taglib uri="uri" prefix = "prefixOfTag" >
Here, the uri attribute value resolves to a location the container understands and the prefix attribute informs a container what bits of markup are custom actions.

You can write the XML equivalent of the above syntax as follows −

<jsp:directive.taglib uri = "uri" prefix = "prefixOfTag" /></p>
      <ul>File Uploading</ul>
<p>Uploading file to the server using JSP
Uploading file to the server using JSP
MultipartRequest class
Constructors of MultipartRequest class
Example of File Upload in JSP
There are many ways to upload the file to the server. One of the way is by the MultipartRequest class. For using this class you need to have the cos.jar file. 
In this example, we are providing the cos.jar file alongwith the code.

MultipartRequest class
It is a utility class to handle the multipart/form-data request. There are many constructors defined in the MultipartRequest class.
Commonly used Constructors of MultipartRequest class
MultipartRequest(HttpServletRequest request, String saveDirectory) uploads the file upto 1MB.
MultipartRequest(HttpServletRequest request, String saveDirectory, int maxPostSize) uploads the file upto specified post size.
MultipartRequest(HttpServletRequest request, String saveDirectory, int maxPostSize, String encoding) uploads the file upto specified post size with given encoding.

 
Example of File Upload in JSP
In this example, we are creating two files only, index.jsp and fileupload.jsp.

index.jsp
To upload the file to the server, there are two requirements:

You must use the post request.
encodeType should be multipart/form-data that gives information to the server that you are going to upload the file.
<form action="upload.jsp" method="post" enctype="multipart/form-data">  
Select File:<input type="file" name="fname"/><br/>  
<input type="image" src="MainUpload.png"/>  
</form>  
upload.jsp
We are uploading the incoming file to the location d:/new, you can specify your location here.

<%@ page import="com.oreilly.servlet.MultipartRequest" %>  
<%  
MultipartRequest m = new MultipartRequest(request, "d:/new");  
out.print("successfully uploaded");    
%>  
If size of the file is greater than 1MB, you should specify the post size.</p>
      <ul>Email</ul>
  <p>
    To send an email using a JSP, you should have the JavaMail API and the Java Activation Framework (JAF) installed on your machine.

You can download the latest version of JavaMail (Version 1.2) from the Java's standard website.

You can download the latest version of JavaBeans Activation Framework JAF (Version 1.0.2) from the Java's standard website.

Download and unzip these files, in the newly-created top-level directories. You will find a number of jar files for both the applications. You need to add the mail.jar and the activation.jar files in your CLASSPATH.

Send a Simple Email
Here is an example to send a simple email from your machine. It is assumed that your localhost is connected to the Internet and that it is capable enough to send an email. Make sure all the jar files from the Java Email API package and the JAF package are available in CLASSPATH.

<%@ page import = "java.io.*,java.util.*,javax.mail.*"%>
<%@ page import = "javax.mail.internet.*,javax.activation.*"%>
<%@ page import = "javax.servlet.http.*,javax.servlet.*" %>

<%
   String result;
   
   // Recipient's email ID needs to be mentioned.
   String to = "abcd@gmail.com";

   // Sender's email ID needs to be mentioned
   String from = "mcmohd@gmail.com";

   // Assuming you are sending email from localhost
   String host = "localhost";

   // Get system properties object
   Properties properties = System.getProperties();

   // Setup mail server
   properties.setProperty("mail.smtp.host", host);

   // Get the default Session object.
   Session mailSession = Session.getDefaultInstance(properties);

   try {
      // Create a default MimeMessage object.
      MimeMessage message = new MimeMessage(mailSession);
      
      // Set From: header field of the header.
      message.setFrom(new InternetAddress(from));
      
      // Set To: header field of the header.
      message.addRecipient(Message.RecipientType.TO,
                               new InternetAddress(to));
      // Set Subject: header field
      message.setSubject("This is the Subject Line!");
      
      // Now set the actual message
      message.setText("This is actual message");
      
      // Send message
      Transport.send(message);
      result = "Sent message successfully....";
   } catch (MessagingException mex) {
      mex.printStackTrace();
      result = "Error: unable to send message....";
   }
%>

<html>
   <head>
      <title>Send Email using JSP</title>
   </head>
   
   <body>
      <center>
         <h1>Send Email using JSP</h1>
      </center>
      
      <p align = "center">
         <% 
            out.println("Result: " + result + "\n");
         %>
      </p>
   </body>
</html>
Let us now put the above code in SendEmail.jsp file and call this JSP using the URL http://localhost:8080/SendEmail.jsp. This will help send an email to the given email ID abcd@gmail.com. You will receive the following response −

Send Email using JSP

Result: Sent message successfully....


If you want to send an email to multiple recipients, then use the following methods to specify multiple email IDs −

void addRecipients(Message.RecipientType type, Address[] addresses)
throws MessagingException
Here is the description of the parameters −

type − This would be set to TO, CC or BCC. Here CC represents Carbon Copy and BCC represents Black Carbon Copy. Example Message.RecipientType.TO

addresses − This is the array of email ID. You would need to use the InternetAddress() method while specifying email IDs

Send an HTML Email
Here is an example to send an HTML email from your machine. It is assumed that your localhost is connected to the Internet and that it is capable enough to send an email. Make sure all the jar files from the Java Email API package and the JAF package are available in CLASSPATH.

This example is very similar to the previous one, except that here we are using the setContent() method to set content whose second argument is "text/html" to specify that the HTML content is included in the message.

Using this example, you can send as big an HTML content as you require.

<%@ page import = "java.io.*,java.util.*,javax.mail.*"%>
<%@ page import = "javax.mail.internet.*,javax.activation.*"%>
<%@ page import = "javax.servlet.http.*,javax.servlet.*" %>

<%
   String result;
   
   // Recipient's email ID needs to be mentioned.
   String to = "abcd@gmail.com";

   // Sender's email ID needs to be mentioned
   String from = "mcmohd@gmail.com";

   // Assuming you are sending email from localhost
   String host = "localhost";

   // Get system properties object
   Properties properties = System.getProperties();

   // Setup mail server
   properties.setProperty("mail.smtp.host", host);

   // Get the default Session object.
   Session mailSession = Session.getDefaultInstance(properties);

   try {
      // Create a default MimeMessage object.
      MimeMessage message = new MimeMessage(mailSession);
      
      // Set From: header field of the header.
      message.setFrom(new InternetAddress(from));
      
      // Set To: header field of the header.
      message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
      
      // Set Subject: header field
      message.setSubject("This is the Subject Line!");
     
      // Send the actual HTML message, as big as you like
      message.setContent("<h1>This is actual message</h1>", "text/html" );
      
      // Send message
      Transport.send(message);
      result = "Sent message successfully....";
   } catch (MessagingException mex) {
      mex.printStackTrace();
      result = "Error: unable to send message....";
   }
%>

<html>
   <head>
      <title>Send HTML Email using JSP</title>
   </head>

   <body>
      <center>
         <h1>Send Email using JSP</h1>
      </center>
      
      <p align = "center">
         <% 
            out.println("Result: " + result + "\n");
         %>
      </p>
   </body>
</html>
Let us now use the above JSP to send HTML message on a given email ID.

Send Attachment in Email
Following is an example to send an email with attachment from your machine −

<%@ page import = "java.io.*,java.util.*,javax.mail.*"%>
<%@ page import = "javax.mail.internet.*,javax.activation.*"%>
<%@ page import = "javax.servlet.http.*,javax.servlet.*" %>

<%
   String result;
   
   // Recipient's email ID needs to be mentioned.
   String to = "abcd@gmail.com";

   // Sender's email ID needs to be mentioned
   String from = "mcmohd@gmail.com";

   // Assuming you are sending email from localhost
   String host = "localhost";

   // Get system properties object
   Properties properties = System.getProperties();

   // Setup mail server
   properties.setProperty("mail.smtp.host", host);

   // Get the default Session object.
   Session mailSession = Session.getDefaultInstance(properties);

   try {
      // Create a default MimeMessage object.
      MimeMessage message = new MimeMessage(mailSession);

      // Set From: header field of the header.
      message.setFrom(new InternetAddress(from));

      // Set To: header field of the header.
      message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));

      // Set Subject: header field
      message.setSubject("This is the Subject Line!");

      // Create the message part 
      BodyPart messageBodyPart = new MimeBodyPart();

      // Fill the message
      messageBodyPart.setText("This is message body");
      
      // Create a multipart message
      Multipart multipart = new MimeMultipart();

      // Set text message part
      multipart.addBodyPart(messageBodyPart);

      // Part two is attachment
      messageBodyPart = new MimeBodyPart();
      
      String filename = "file.txt";
      DataSource source = new FileDataSource(filename);
      messageBodyPart.setDataHandler(new DataHandler(source));
      messageBodyPart.setFileName(filename);
      multipart.addBodyPart(messageBodyPart);

      // Send the complete message parts
      message.setContent(multipart );

      // Send message
      Transport.send(message);
      String title = "Send Email";
      result = "Sent message successfully....";
   } catch (MessagingException mex) {
      mex.printStackTrace();
      result = "Error: unable to send message....";
   }
%>

<html>
   <head>
      <title>Send Attachment Email using JSP</title>
   </head>
   
   <body>
      <center>
         <h1>Send Attachment Email using JSP</h1>
      </center>
      
      <p align = "center">
         <%out.println("Result: " + result + "\n");%>
      </p>
   </body>
</html>
Let us now run the above JSP to send a file as an attachment along with a message on a given email ID.

User Authentication Part
If it is required to provide user ID and Password to the email server for authentication purpose, then you can set these properties as follows −

props.setProperty("mail.user", "myuser");
props.setProperty("mail.password", "mypwd");
Rest of the email sending mechanism will remain as explained above.

Using Forms to Send Email
You can use HTML form to accept email parameters and then you can use the request object to get all the information as follows −

String to = request.getParameter("to");
String from = request.getParameter("from");
String subject = request.getParameter("subject");
String messageText = request.getParameter("body");</p>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
  </body>
</html>
